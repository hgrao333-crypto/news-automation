#!/usr/bin/env python3
"""
Main script to generate automated 60-second news shorts for YouTube
"""

import argparse
from datetime import datetime
import os
from news_fetcher import NewsFetcher
from content_generator import ContentGenerator
from image_generator import ImageGenerator
from tts_generator import TTSGenerator
from video_generator import VideoGenerator
from youtube_uploader import YouTubeUploader
from config import NEWS_API_KEY, YOUTUBE_AUTO_UPLOAD, YOUTUBE_PRIVACY_STATUS, YOUTUBE_CATEGORY_ID

def generate_today_in_60_seconds():
    """Generate 'Today in 60 seconds' video"""
    print("=" * 60)
    print("Generating 'Today in 60 Seconds' video...")
    print("=" * 60)
    
    # Step 1: Fetch news
    print("\n[1/6] Fetching today's top news...")
    print("  ðŸ‡®ðŸ‡³ Using Indian news sources...")
    fetcher = NewsFetcher(news_api_key=NEWS_API_KEY, country="in")  # India
    
    all_articles = fetcher.fetch_today_news(limit=25)  # Fetch more initially
    print(f"Found {len(all_articles)} articles")
    
    if not all_articles:
        print("No articles found. Exiting.")
        return None
    
    # Step 2: Analyze and select most important news with diversity
    print("\n[2/6] Analyzing news importance with Ollama (ensuring diversity)...")
    generator = ContentGenerator()
    articles = generator.analyze_and_select_important_news(all_articles, select_count=8, ensure_diversity=True)
    print(f"Selected {len(articles)} most important stories:")
    for i, article in enumerate(articles, 1):
        print(f"  {i}. {article['title'][:60]}")
    
    # Step 3: Generate content script
    print("\n[3/6] Generating content script with Ollama...")
    script_data = generator.generate_today_in_60_seconds(articles)
    print(f"Title: {script_data.get('title', 'Untitled')}")
    print(f"Script length: {len(script_data.get('script', ''))} characters")
    
    # Step 3.5: Prepare segments for display
    # Text panel will show: headline text for headlines, summary text for summaries
    print("\n[3.5/6] Preparing segments for video display...")
    segments = script_data.get('segments', [])
    for i, segment in enumerate(segments):
        segment_type = segment.get('type', 'summary')
        segment_text = segment.get('text', '')
        print(f"  Segment {i+1} ({segment_type}): {segment_text[:70]}...")
    
    # Step 4: Generate images using Ollama-generated prompts
    print("\n[4/6] Generating images from news-specific prompts...")
    image_gen = ImageGenerator()
    
    # Get prompts from script_data (should already be generated by content_generator)
    # Note: image_prompts should have ONE prompt per story (not per segment)
    # Hook + 3 stories + closing = 5 prompts total
    image_prompts = script_data.get('image_prompts', [])
    # Ensure all prompts are strings (they might be dicts or other types)
    image_prompts = [
        p if isinstance(p, str) else (p.get('text', str(p)) if isinstance(p, dict) else str(p))
        for p in image_prompts
    ]
    segments = script_data.get('segments', [])
    
    # Extract unique story image prompts (one per story)
    # Count stories by story_index
    story_indices = set()
    for segment in segments:
        story_idx = segment.get('story_index')
        if story_idx is not None:
            story_indices.add(story_idx)
    
    num_stories = len(story_indices)
    # Expected: 8 stories + 1 closing = 9 prompts (no hook/opening segment)
    expected_prompts = num_stories + 1  # Stories + closing
    
    print(f"  ðŸ“Š Found {num_stories} stories, expecting {expected_prompts} image prompts")
    
    # Double-check: if prompts are still generic or missing, regenerate
    generic_keywords = ['professional news broadcast studio', 'breaking news headline', 'news anchor presenting']
    needs_regeneration = False
    
    if not image_prompts or len(image_prompts) < expected_prompts:
        needs_regeneration = True
        print(f"âš ï¸  Image prompts missing or incomplete ({len(image_prompts)} prompts, need {expected_prompts}). Regenerating with Ollama...")
    else:
        # Check first story prompt for generic keywords (skip hook)
        # Ensure prompt is a string before checking
        if len(image_prompts) > 1:
            first_story_prompt = image_prompts[1]
            if isinstance(first_story_prompt, str):
                if any(kw.lower() in first_story_prompt.lower() for kw in generic_keywords):
                    needs_regeneration = True
                    print("âš ï¸  Detected generic prompts. Regenerating with Ollama...")
            elif isinstance(first_story_prompt, dict):
                # If it's a dict, convert to string or regenerate
                needs_regeneration = True
                print("âš ï¸  Image prompts are in wrong format (dict instead of string). Regenerating with Ollama...")
    
    if needs_regeneration:
        image_prompts = generator._generate_image_prompts_with_ollama(segments, articles, None)
        script_data['image_prompts'] = image_prompts  # Update script_data
    
    if not image_prompts:
        print("âš ï¸  Using fallback prompts as last resort")
        # Only use fallback if Ollama completely fails
        image_prompts = [
            "News broadcast opening scene",
            f"Breaking news: {articles[0]['title'][:40]}" if articles else "Breaking news headline",
            f"News story: {articles[1]['title'][:40]}" if len(articles) > 1 else "Important news update",
            f"Latest: {articles[2]['title'][:40]}" if len(articles) > 2 else "News coverage",
            "News broadcast closing scene",
        ]
    
    print(f"\nâœ… Using {len(image_prompts)} image prompts (one per story):")
    print("=" * 60)
    for i, prompt in enumerate(image_prompts, 1):
        # Ensure prompt is a string for display
        prompt_str = prompt if isinstance(prompt, str) else str(prompt)
        print(f"\n  Prompt {i}/{len(image_prompts)}:")
        print(f"  {prompt_str}")
    print("=" * 60)
    
    # Ensure all prompts are strings and clean HTML tags
    import re
    cleaned_prompts = []
    for p in image_prompts:
        if isinstance(p, str):
            # Remove HTML tags
            cleaned = re.sub(r'<[^>]+>', '', p)
            # Remove HTML entities
            cleaned = cleaned.replace('&nbsp;', ' ').replace('&amp;', '&')
            cleaned = cleaned.replace('&lt;', '<').replace('&gt;', '>')
            cleaned = cleaned.replace('&quot;', '"').replace('&#39;', "'")
            # Clean up whitespace
            cleaned = ' '.join(cleaned.split())
            # Skip if it looks like HTML (contains img tags or src=)
            if cleaned.startswith('<img') or 'src=' in cleaned.lower() or len(cleaned) < 10:
                # Use fallback prompt
                article_idx = len(cleaned_prompts) - 1  # -1 because we haven't added this one yet
                if article_idx < len(articles):
                    cleaned = f"Breaking news: {articles[article_idx]['title'][:50]}"
                else:
                    cleaned = "News broadcast scene"
            cleaned_prompts.append(cleaned)
        else:
            cleaned_prompts.append(str(p))
    image_prompts = cleaned_prompts
    
    image_paths = image_gen.generate_images_for_segments(image_prompts)
    print(f"\nâœ… Generated {len(image_paths)} images")
    
    # Step 5: Generate TTS audio with segment timing
    print("\n[5/6] Generating text-to-speech audio with segment timing...")
    tts = TTSGenerator()
    segments = script_data.get('segments', [])
    if segments:
        # Generate segmented audio to get accurate timing
        audio_path, segment_timings = tts.generate_segmented_audio(segments, "today_audio.mp3")
        # Update script_data with actual timings
        for i, timing in enumerate(segment_timings):
            if i < len(script_data['segments']):
                script_data['segments'][i]['start_time'] = timing['start_time']
                script_data['segments'][i]['duration'] = timing['duration']
    else:
        # Fallback to single audio generation
        script_text = script_data.get('script', '')
        audio_path = tts.generate_audio(script_text, "today_audio.mp3")
        segment_timings = None
    
    if not audio_path:
        print("Failed to generate audio. Exiting.")
        return None
    
    # Step 6: Create video synced with audio segments
    print("\n[6/6] Creating final video with synced images and audio...")
    video_gen = VideoGenerator()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filename = f"today_in_60_seconds_{timestamp}.mp4"
    video_path = video_gen.create_video(image_paths, audio_path, script_data, output_filename, segment_timings)
    
    if video_path:
        print(f"\nâœ… Success! Video saved to: {video_path}")
        
        # Optional: Upload to YouTube
        upload_enabled = YOUTUBE_AUTO_UPLOAD or os.getenv('YOUTUBE_AUTO_UPLOAD', 'false').lower() == 'true'
        if upload_enabled:
            upload_to_youtube(video_path, script_data.get('title', 'Today in 60 Seconds'))
        
        return video_path
    else:
        print("\nâŒ Failed to create video.")
        return None

def generate_hot_topic_video(topic: str = None):
    """Generate video about a hot topic"""
    print("=" * 60)
    print("Generating 'Hot Topic' video...")
    print("=" * 60)
    
    # Step 1: Fetch news about topic
    print(f"\n[1/6] Fetching news about topic: {topic or 'trending topic'}...")
    fetcher = NewsFetcher(news_api_key=NEWS_API_KEY)
    all_articles = fetcher.fetch_hot_topic(topic=topic, limit=20)  # Fetch more initially
    print(f"Found {len(all_articles)} articles")
    
    if not all_articles:
        print("No articles found. Exiting.")
        return None
    
    # Determine topic from articles if not provided
    if not topic and all_articles:
        topic = all_articles[0]['title'].split()[0:3]
        topic = ' '.join(topic)
    
    # Step 2: Analyze and select most important/relevant news
    print("\n[2/6] Analyzing news relevance and importance with Ollama...")
    generator = ContentGenerator()
    articles = generator.analyze_and_select_important_news(all_articles, select_count=7)
    print(f"Selected {len(articles)} most important stories:")
    for i, article in enumerate(articles, 1):
        print(f"  {i}. {article['title'][:60]}")
    
    # Step 3: Generate content script
    print("\n[3/6] Generating content script with Ollama...")
    script_data = generator.generate_hot_topic_script(topic, articles)
    print(f"Title: {script_data.get('title', 'Untitled')}")
    print(f"Script length: {len(script_data.get('script', ''))} characters")
    
    # Step 3.5: Prepare segments for display
    # Text panel will show: headline text for headlines, summary text for summaries
    print("\n[3.5/6] Preparing segments for video display...")
    segments = script_data.get('segments', [])
    for i, segment in enumerate(segments):
        segment_type = segment.get('type', 'summary')
        segment_text = segment.get('text', '')
        print(f"  Segment {i+1} ({segment_type}): {segment_text[:70]}...")
    
    # Step 4: Generate images using Ollama-generated prompts
    print("\n[4/6] Generating images from news-specific prompts...")
    image_gen = ImageGenerator()
    image_prompts = script_data.get('image_prompts', [])
    
    # Ensure we have prompts for all segments
    segments = script_data.get('segments', [])
    if not image_prompts or len(image_prompts) < len(segments):
        print("âš ï¸  Image prompts missing or incomplete. Generating with Ollama...")
        # Generate prompts using Ollama
        image_prompts = generator._generate_image_prompts_with_ollama(segments, articles, topic)
    
    if not image_prompts:
        print("âš ï¸  Using fallback prompts as last resort")
        # Only use fallback if Ollama completely fails
        image_prompts = [
            f"Visual representation of {topic}",
            f"Breaking news about {topic}",
            f"News coverage of {topic}",
        ]
    
    print(f"\nâœ… Using {len(image_prompts)} news-specific image prompts:")
    print("=" * 60)
    for i, prompt in enumerate(image_prompts, 1):
        print(f"\n  Prompt {i}/{len(image_prompts)}:")
        print(f"  {prompt}")
    print("=" * 60)
    
    image_paths = image_gen.generate_images_for_segments(image_prompts)
    print(f"\nâœ… Generated {len(image_paths)} images")
    
    # Step 5: Generate TTS audio with segment timing
    print("\n[5/6] Generating text-to-speech audio with segment timing...")
    tts = TTSGenerator()
    segments = script_data.get('segments', [])
    if segments:
        # Generate segmented audio to get accurate timing
        audio_path, segment_timings = tts.generate_segmented_audio(segments, "topic_audio.mp3")
        # Update script_data with actual timings
        for i, timing in enumerate(segment_timings):
            if i < len(script_data['segments']):
                script_data['segments'][i]['start_time'] = timing['start_time']
                script_data['segments'][i]['duration'] = timing['duration']
    else:
        # Fallback to single audio generation
        script_text = script_data.get('script', '')
        audio_path = tts.generate_audio(script_text, "topic_audio.mp3")
        segment_timings = None
    
    if not audio_path:
        print("Failed to generate audio. Exiting.")
        return None
    
    # Step 6: Create video synced with audio segments
    print("\n[6/6] Creating final video with synced images and audio...")
    video_gen = VideoGenerator()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    safe_topic = "".join(c for c in topic if c.isalnum() or c in (' ', '-', '_')).strip()[:30]
    output_filename = f"hot_topic_{safe_topic}_{timestamp}.mp4"
    video_path = video_gen.create_video(image_paths, audio_path, script_data, output_filename, segment_timings)
    
    if video_path:
        print(f"\nâœ… Success! Video saved to: {video_path}")
        
        # Optional: Upload to YouTube
        upload_enabled = YOUTUBE_AUTO_UPLOAD or os.getenv('YOUTUBE_AUTO_UPLOAD', 'false').lower() == 'true'
        if upload_enabled:
            upload_to_youtube(video_path, script_data.get('title', 'Hot Topic Video'))
        
        return video_path
    else:
        print("\nâŒ Failed to create video.")
        return None

def upload_to_youtube(video_path: str, title: str, description: str = "", tags: list = None):
    """
    Upload video to YouTube
    
    Args:
        video_path: Path to video file
        title: Video title
        description: Video description (optional)
        tags: List of tags (optional)
    """
    try:
        print("\n" + "=" * 60)
        print("ðŸ“¤ Uploading to YouTube...")
        print("=" * 60)
        
        uploader = YouTubeUploader()
        
        # Generate description if not provided
        if not description:
            description = f"""ðŸ“° {title}

Stay informed with the latest news updates!

#News #BreakingNews #NewsUpdate #YouTubeShorts

Generated automatically with AI news automation."""
        
        # Default tags if not provided
        if not tags:
            tags = ["news", "breaking news", "news update", "youtube shorts", "ai news"]
        
        result = uploader.upload_video(
            video_path=video_path,
            title=title,
            description=description,
            tags=tags,
            category_id=YOUTUBE_CATEGORY_ID,
            privacy_status=YOUTUBE_PRIVACY_STATUS
        )
        
        if result:
            print(f"\nðŸŽ‰ Video published successfully!")
            print(f"   Watch it here: {result['url']}")
            return result
        else:
            print("\nâš ï¸  YouTube upload failed, but video is saved locally")
            return None
            
    except Exception as e:
        print(f"\nâš ï¸  Error uploading to YouTube: {e}")
        print("   Video is saved locally and can be uploaded manually")
        return None

def main():
    parser = argparse.ArgumentParser(description='Generate automated 60-second news shorts')
    parser.add_argument(
        '--type',
        choices=['today', 'topic'],
        default='today',
        help='Type of video to generate: "today" for daily summary, "topic" for hot topic'
    )
    parser.add_argument(
        '--topic',
        type=str,
        help='Specific topic for hot topic video (optional)'
    )
    parser.add_argument(
        '--upload',
        action='store_true',
        help='Upload video to YouTube after generation'
    )
    
    args = parser.parse_args()
    
    # Override auto-upload if --upload flag is provided
    if args.upload:
        import os
        os.environ['YOUTUBE_AUTO_UPLOAD'] = 'true'
    
    if args.type == 'today':
        generate_today_in_60_seconds()
    elif args.type == 'topic':
        generate_hot_topic_video(args.topic)

if __name__ == "__main__":
    main()

